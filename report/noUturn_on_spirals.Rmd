---
title: "UseCase_LogisticRonSpirals"
author: "Henri Funk"
date: "2 12 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
longrun = FALSE

devtools::load_all()
library(mlbench)
library(ggplot2)
library(gridExtra)
```

20-Dimensional Multivariate Normal

```{r, eval=longrun}
posterior_density = mvtnorm::dmvnorm
gradient <- function(position){exp(-position)}
sample50norm <- sample_noUturn(position_init = runif(50, -5, -2), iteration = 2e3, is_log = FALSE)
```

```{r, echo =FALSE, eval=longrun}
saveRDS(sample50norm, file = "files/sample50norm.rds")
```

```{r, echo = FALSE, eval =!longrun}
sample20norm <- readRDS("files/sample20norm.rds")
```

```{r traceplot}
ggplot(data = sample20norm, aes(x = seq_len(2000), y = X1)) +
  geom_line()
ggplot(data = sample20norm, aes(x = X1)) +
  geom_density()
```





<!--
To recheck the code is still up to date and syntax sticks to the current mlr3 version initialize `long_run = TRUE`.
This will run *all* code chunks no matter the computational effort.
-->

## SetUp Experiment

```{r}
library(hmclearn)
data(Endometrial)

# data prep
Endometrial$PI2 <- with(Endometrial, (PI - mean(PI)) / sd(PI))
Endometrial$EH2 <- with(Endometrial, (EH - mean(EH)) / sd(EH))
Endometrial$NV2 <- Endometrial$NV - 0.5

X <- cbind(1, as.matrix(Endometrial[, which(colnames(Endometrial)
            %in% c("PI2", "EH2", "NV2"))]))
y <- Endometrial$HG

colnames(X) <- c("(Intercept)", "PI2", "EH2", "NV2")
```

Define posterior and gradient function

```{r}
devtools::load_all()
posterior_density = bernoulli_pen
gradient = partial_deriv_sigmoid
```


Run `naive_nouturn_sampler` for 2000 iterations with a small stepsize of `0.45`
As our posterior is already logged we ca specify the `is_logged` argument as `TRUE`

We use a GAM with 2 position estimates indicating sinus of their true position here
to consider spirals nonlinear structure.

```{r, eval=longrun}
start <- Sys.time()
initial_pos <- lapply(1:3, function(x) runif(9, -5, 5))
sigmoid_parameter_distrib <- lapply(initial_pos, sample_noUturn, iteration = 2e3, design = design, target = target, is_log = TRUE, seed = 123L, target_accpentance = .39, max_tree_depth = 11L)
dif2000iter <- Sys.time() - start
dif2000iter
```

```{r eval=longrun, echo=FALSE}
saveRDS(object = dif3000iter, file = "files/runtime2000iter.RDS")
saveRDS(object = sigmoid_parameter_distrib2, file = "files/sigmoid_parameter_distrib2.RDS")
```

```{r eval=!longrun, echo=FALSE}
readRDS("runtime2000iter.RDS")
sigmoid_parameter_distrib <- readRDS("sigmoid_parameter_distrib.RDS")
```

## Check for convergence

Acceptance rate

Trace Plot for parameters

```{r}
calculate_traceplots <- function(var, varname, lim = c(-50, 100), iter = 3e3){
  ggplot(data = sigmoid_parameter_distrib2[[1]], aes_string(x = seq_len(iter), y = var)) +
    geom_line(color = "red") + labs(x = "iteration", y = varname) +# ylim(lim) +
    geom_line(data =sigmoid_parameter_distrib2[[2]],
            aes_string(x = seq_len(iter), y = var), color = "blue") +
    geom_line(data =sigmoid_parameter_distrib2[[3]],
            aes_string(x = seq_len(iter), y = var), color = "green")
    #annotate("rect", xmin = 1251, xmax = 2000, ymin = -150, ymax = 150, alpha = .2)
}

args <- list(
  list(var = "X1", varname = "intercept"), list(var = "X2", varname = "slope2"),
  list(var = "X3", varname = "slope3"), list(var = "X4", varname = "slope4")
  ,
  list(var = "X5", varname = "slope5"), list(var = "X6", varname = "slope6"),
  list(var = "X7", varname = "slope7"), list(var = "X8", varname = "slope8"),
  list(var = "X9", varname = "slope9")
  )
# lapply(scale_estimate, function(x) args$lim <- x)

traceplots <- lapply(args, function(x) do.call(calculate_traceplots, x))

do.call(grid.arrange, c(traceplots, nrow = 3))

```

Slopes seem to converge after 1000 to 1250 iterations, while intercept is already quite stable from the beginning.

\rightarrow Leave out first 1250 iterations as burn in and calculate position estimates means and variance

```{r}
param_distrib <- lapply(sigmoid_parameter_distrib2, function(x){
  x[-seq_len(1000),]
})

calc_density_plots <- function(var, varname) {
  ggplot() +
    geom_density(data = param_distrib[[1]], aes_string(x = var), color = "red") + 
    geom_density(data = param_distrib[[2]], aes_string(x = var), color = "blue") + 
    geom_density(data = param_distrib[[3]], aes_string(x = var), color = "green") +
    ggtitle(paste("density", varname))
}

calc_density_plots(args[[1]]$var, args[[1]]$varname)
density <- lapply(args, function(x)calc_density_plots(x$var, x$varname))
do.call(grid.arrange, c(density, nrow = 3))
```

## Mean Estimation

```{r}
mean_estimate <- lapply(param_distrib, colMeans)

calc <- lapply(mean_estimate, function(x) {
  1- 2/(1+ exp(design %*% x[-c(10,11)]))
})
lapply(calc, function(x){
  sum(abs(round(target - x)) == 2) / nrow(x)
})
```

```{r}
test_target <- as.numeric(testPID$diabetes)
test_target[which(test_target ==2)] = -1

design_test <- cbind(1, scale(as.matrix(testPID[, -9])))


calc <- lapply(mean_estimate, function(x) {
  1- 2/(1+ exp(design_test %*% x[-c(10,11)]))
})
lapply(calc, function(x){
  sum(abs(round(test_target - x)) == 2) / nrow(x)
})
```


## Check Modell

```{r}
sigmoid_map <- function(x) {
  1 / (1 + exp(-x))
}

max <- apply(design[, 2:3], 2, max)
min <- apply(design[, 2:3], 2, min)
dim1 <- seq(from = min[1], to = max[1], length.out = 20)
dim2 <- seq(from = min[2], to = max[2], length.out = 20)
grid <- cbind(1, expand.grid("dim1" = dim1, "dim2" = dim2),
              "sin1" = sin(dim1), "sin2" = sin(dim2))
grid <- as.matrix(grid)

estimates <- sigmoid_map(design_2 %*% position_mean)

spirals


spirals+
  geom_raster(data = as.data.frame(grid), aes(x = dim1, y = dim2, fill = estimates))
```

# Regression

Data Set Information:

The data was retrieved from a set of 53500 CT images from 74 different
patients (43 male, 31 female).

Each CT slice is described by two histograms in polar space.
The first histogram describes the location of bone structures in the image,
the second the location of air inclusions inside of the body.
Both histograms are concatenated to form the final feature vector.
Bins that are outside of the image are marked with the value -0.25.

The class variable (relative location of an image on the axial axis) was
constructed by manually annotating up to 10 different distinct landmarks in
each CT Volume with known location. The location of slices in between
landmarks was interpolated.


Attribute Information:

1. patientId: Each ID identifies a different patient
2. - 241.: Histogram describing bone structures
242. - 385.: Histogram describing air inclusions
386. reference: Relative location of the image on the axial axis (class
value). Values are in the range [0; 180] where 0 denotes
the top of the head and 180 the soles of the feet.

```{r}
tmp <- tempfile()
download.file(
  "https://archive.ics.uci.edu/ml/machine-learning-databases/00206/slice_localization_data.zip",
  tmp)
ct_slice <- read.csv(unz(tmp, filename = "slice_localization_data.csv"), as.is = TRUE)
```

```{r}
id <- sample(seq_len(53500), 1e4)
trainCT <- ct_slice[id, ]
target <- trainCT[, 386]
design <- as.matrix(cbind(1, trainCT[, -386]))
c(min(target), max(target)) # -> map on real numbers, maybe gamma distrib...
```

```{r}
devtools::load_all()
posterior_density = gamma_distr
gradient = partial_deriv_gamma
```

```{r}
start <- Sys.time()
initial_pos <- lapply(1:3, function(x) runif(386, -20, 20))
sigmoid_parameter_distrib <- lapply(initial_pos, sample_noUturn, iteration = 10, design = design, target = target, is_log = TRUE, seed = 123L, target_accpentance = .65, max_tree_depth = 11L)
dif2000iter <- Sys.time() - start
dif2000iter
```

