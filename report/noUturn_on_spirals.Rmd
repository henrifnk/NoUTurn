---
title: "UseCase_LogisticRonSpirals"
author: "Henri Funk"
date: "2 12 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
longrun = FALSE

devtools::load_all()
library(mlbench)
library(ggplot2)
library(gridExtra)
```

<!--
To recheck the code is still up to date and syntax sticks to the current mlr3 version initialize `long_run = TRUE`.
This will run *all* code chunks no matter the computational effort.
-->

## SetUp Experiment

Generate spiral data set from `mlbench` package
Note: as sigmoid maps from $\mathbb{R}$ to binary classes $[0, 1]$ we need to respecify our target weights here.

```{r, eval=longrun}
data(PimaIndiansDiabetes)
#sample 70% train dataset
id <- sample(seq_len(nrow(PimaIndiansDiabetes)), size = 0.7*nrow(PimaIndiansDiabetes))
trainPID <-  PimaIndiansDiabetes[id, ]
testPID <- PimaIndiansDiabetes[-id, ]
str(PimaIndiansDiabetes)
```

### Data Set

The data set is comprised of 768 observations and 9 variables. It is available in the package mlbench. We will be using diabetes as our response/target variable.

Data Description for the 9 variables are as follows.

pregnant - Number of times pregnant
glucose - Plasma glucose concentration (glucose tolerance test)
pressure - Diastolic blood pressure (mm Hg)
triceps - Triceps skin fold thickness (mm)
insulin - 2-Hour serum insulin (mu U/ml)
mass - Body mass index (weight in kg/(height in m)^2)
pedigree - Diabetes pedigree function
age - Age (years)
diabetes - Class variable (test for diabetes)

```{r}
DataExplorer::plot_density(data = trainPID)

ggplot(trainPID, aes(diabetes, fill = diabetes)) + 
  geom_bar() +
  theme_bw() +
  labs(title = "Diabetes Classification", x = "Diabetes") +
  theme(plot.title = element_text(hjust = 0.5))
```


```{r eval=longrun, echo=FALSE}
saveRDS(object = trainPID, file = "files/train.RDS")
saveRDS(object = testPID, file = "files/test.RDS")
```

```{r eval=!longrun, echo=FALSE}
trainPID <- readRDS("files/train.RDS")
testPID <- readRDS("files/test.RDS")
```

## Scaling

Scale for better distribution around 0


```{r}
design <- scale(trainPID[, -9])
scale_train <- attributes(design)[c("scaled:center", "scaled:scale")]
design <- cbind(1, design)
target <- as.numeric(trainPID$diabetes)
target[which(target == 2)] = -1 # Change classlevels to {-1, 1}
```

Define posterior and gradient function

```{r}
# TODO: describe functions and how we got there

devtools::load_all()
posterior_density = sigmoid_posterior
gradient = partial_deriv_sigmoid
```


Run `naive_nouturn_sampler` for 2000 iterations with a small stepsize of `0.45`
As our posterior is already logged we ca specify the `is_logged` argument as `TRUE`

We use a GAM with 2 position estimates indicating sinus of their true position here
to consider spirals nonlinear structure.

```{r, eval=longrun}
start <- Sys.time()
scale_estimate <- list(c(75, 125), c(-25, 25), c(-125, -75), c(0, 50),
                       c(50, 100), c(-75, -25), c(-50, 50), c(-25, 25),
                       c(0, 50))
initial_pos <- lapply(1:3, function(x) sapply(scale_estimate, function(y) runif(1, y[1], y[2])))
sigmoid_parameter_distrib <- lapply(initial_pos, naive_nouturn_sampler, stepsize = .01, iteration = 2e3, design = design, target = target, is_log = TRUE, seed = 123L)
dif2000iter <- Sys.time() - start
dif2000iter
```

```{r eval=longrun, echo=FALSE}
saveRDS(object = dif2000iter, file = "runtime2000iter.RDS")
saveRDS(object = sigmoid_parameter_distrib, file = "sigmoid_parameter_distrib.RDS")
```

```{r eval=!longrun, echo=FALSE}
readRDS("runtime2000iter.RDS")
sigmoid_parameter_distrib <- readRDS("sigmoid_parameter_distrib.RDS")
```

## Check for convergence

Acceptance rate

Quick reminder: good indicator is a accaptance around 50%

```{r}
lapply(sigmoid_parameter_distrib, function(x) mean(x$acceptance_rate))
lapply(sigmoid_parameter_distrib, function(x) mean(x$tree_depth))
```


Trace Plot for parameters

```{r}
calculate_traceplots <- function(var, varname, lim = c(-150, 150), iter = 2e3){
  ggplot(data = sigmoid_parameter_distrib[[1]], aes_string(x = seq_len(iter), y = var)) +
    geom_line(color = "red") + labs(x = "iteration", y = varname) + ylim(lim) +
    geom_line(data =sigmoid_parameter_distrib[[2]],
            aes_string(x = seq_len(iter), y = var), color = "blue") +
    geom_line(data =sigmoid_parameter_distrib[[3]],
            aes_string(x = seq_len(iter), y = var), color = "green")
    #annotate("rect", xmin = 1251, xmax = 2000, ymin = -150, ymax = 150, alpha = .2)
}

args <- list(
  list(var = "X1", varname = "intercept"), list(var = "X2", varname = "slope2"),
  list(var = "X3", varname = "slope3"), list(var = "X4", varname = "slope4"),
  list(var = "X5", varname = "slope5"), list(var = "X6", varname = "slope6"),
  list(var = "X7", varname = "slope7"), list(var = "X8", varname = "slope8"),
  list(var = "X9", varname = "slope9"))
# lapply(scale_estimate, function(x) args$lim <- x)

traceplots <- lapply(args, function(x) do.call(calculate_traceplots, x))

do.call(grid.arrange, c(traceplots, nrow = 3))

```

Slopes seem to converge after 1000 to 1250 iterations, while intercept is already quite stable from the beginning.

\rightarrow Leave out first 1250 iterations as burn in and calculate position estimates means and variance

```{r}
param_distrib <- lapply(sigmoid_parameter_distrib, function(x){
  x[-seq_len(1e3),]
})

calc_density_plots <- function(var, varname) {
  ggplot() +
    geom_density(data = param_distrib[[1]], aes_string(x = var), color = "red") + 
    geom_density(data = param_distrib[[2]], aes_string(x = var), color = "blue") + 
    geom_density(data = param_distrib[[3]], aes_string(x = var), color = "green") +
    ggtitle(paste("density", varname))
}

calc_density_plots(args[[1]]$var, args[[1]]$varname)
density <- lapply(args, function(x)calc_density_plots(x$var, x$varname))
do.call(grid.arrange, c(density, nrow = 3))
```

## Mean Estimation

```{r}
mean_estimate <- lapply(param_distrib, colMeans)

calc <- lapply(mean_estimate, function(x) {
  design %*% x[-c(10,11)]
})
```


## Check Modell

```{r}
sigmoid_map <- function(x) {
  1 / (1 + exp(-x))
}

max <- apply(design[, 2:3], 2, max)
min <- apply(design[, 2:3], 2, min)
dim1 <- seq(from = min[1], to = max[1], length.out = 20)
dim2 <- seq(from = min[2], to = max[2], length.out = 20)
grid <- cbind(1, expand.grid("dim1" = dim1, "dim2" = dim2),
              "sin1" = sin(dim1), "sin2" = sin(dim2))
grid <- as.matrix(grid)

estimates <- sigmoid_map(design_2 %*% position_mean)

spirals


spirals+
  geom_raster(data = as.data.frame(grid), aes(x = dim1, y = dim2, fill = estimates))
```

