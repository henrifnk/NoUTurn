state$valid_state <- unite_valid_states(state_proposal, state)
} else{
state$valid_state <- unite_valid_states(state, state_proposal)
state$rightmost <- state_proposal$rightmost
}
}
state$run <- state_proposal$run * is_U_turn(state = state)
tree_depth <- tree_depth + 1
cat("tree_depth = ", tree_depth,
"\n direction = ", state$direction)
}
# Initialize state to call on Build Tree
state <- initialize_state(position, momentum, slice, stepsize)
tree_depth <- 0L
# 1 means forward, -1 means backward doubling
state$direction <- sample(c(-1L, 1L), 1L)
state_proposal <- build_tree(state, tree_depth)
state_proposal
if(state_proposal$run) {
if(state_proposal$direction == -1) {
# Sort backward doubled trajectory reversely
state_proposal$valid_state <- lapply(state_proposal$valid_state, function(x) apply(x, 2, rev))
state$leftmost <- state_proposal$leftmost
state$valid_state <- unite_valid_states(state_proposal, state)
} else{
state$valid_state <- unite_valid_states(state, state_proposal)
state$rightmost <- state_proposal$rightmost
}
}
state_proposal$direction == -1
nrow(state_proposal$valid_state$position)
nrow(state_proposal$valid_state$position) > 1
state_proposal$valid_state$position
is.matrix(state_proposal$valid_state$position)
if(state_proposal$direction == -1 && is.matrix(state_proposal$valid_state$position)) {
# Sort backward doubled trajectory reversely
state_proposal$valid_state <- lapply(state_proposal$valid_state, function(x) apply(x, 2, rev))
state$leftmost <- state_proposal$leftmost
state$valid_state <- unite_valid_states(state_proposal, state)
} else{
state$valid_state <- unite_valid_states(state, state_proposal)
state$rightmost <- state_proposal$rightmost
}
if(state_proposal$run) {
if(state_proposal$direction == -1 && is.matrix(state_proposal$valid_state$position)) {
# Sort backward doubled trajectory reversely
state_proposal$valid_state <- lapply(state_proposal$valid_state, function(x) apply(x, 2, rev))
state$leftmost <- state_proposal$leftmost
state$valid_state <- unite_valid_states(state_proposal, state)
} else{
state$valid_state <- unite_valid_states(state, state_proposal)
state$rightmost <- state_proposal$rightmost
}
}
state$run <- state_proposal$run * is_U_turn(state = state)
state$run
tree_depth <- tree_depth + 1
cat("tree_depth = ", tree_depth,
"\n direction = ", state$direction)
# 1 means forward, -1 means backward doubling
state$direction <- sample(c(-1L, 1L), 1L)
state_proposal <- build_tree(state, tree_depth)
if(state_proposal$run) {
if(state_proposal$direction == -1 && is.matrix(state_proposal$valid_state$position)) {
# Sort backward doubled trajectory reversely
state_proposal$valid_state <- lapply(state_proposal$valid_state, function(x) apply(x, 2, rev))
state$leftmost <- state_proposal$leftmost
state$valid_state <- unite_valid_states(state_proposal, state)
} else{
state$valid_state <- unite_valid_states(state, state_proposal)
state$rightmost <- state_proposal$rightmost
}
}
state$valid_state
cat("trajectory = ", state$valid_state,
"\n direction = ", state$direction)
state$valid_state
momentum <- rnorm(length(position))
slice <- runif(1L, max = joint_probability(position, momentum))
# 1 means forward, -1 means backward doubling
state$direction <- sample(c(-1L, 1L), 1L)
state_proposal <- build_tree(state, tree_depth)
if(state_proposal$run) {
if(state_proposal$direction == -1 && is.matrix(state_proposal$valid_state$position)) {
# Sort backward doubled trajectory reversely
state_proposal$valid_state <- lapply(state_proposal$valid_state, function(x) apply(x, 2, rev))
state$leftmost <- state_proposal$leftmost
state$valid_state <- unite_valid_states(state_proposal, state)
} else{
state$valid_state <- unite_valid_states(state, state_proposal)
state$rightmost <- state_proposal$rightmost
}
}
state$run <- state_proposal$run * is_U_turn(state = state)
tree_depth <- tree_depth + 1
state$valid_state
tree_depth
state$run
# 1 means forward, -1 means backward doubling
state$direction <- sample(c(-1L, 1L), 1L)
state_proposal <- build_tree(state, tree_depth)
if(state_proposal$run) {
if(state_proposal$direction == -1 && is.matrix(state_proposal$valid_state$position)) {
# Sort backward doubled trajectory reversely
state_proposal$valid_state <- lapply(state_proposal$valid_state, function(x) apply(x, 2, rev))
state$leftmost <- state_proposal$leftmost
state$valid_state <- unite_valid_states(state_proposal, state)
} else{
state$valid_state <- unite_valid_states(state, state_proposal)
state$rightmost <- state_proposal$rightmost
}
}
state$run <- state_proposal$run * is_U_turn(state = state)
state
state$run
tree_depth <- tree_depth + 1
# 1 means forward, -1 means backward doubling
state$direction <- sample(c(-1L, 1L), 1L)
state_proposal <- build_tree(state, tree_depth)
if(state_proposal$run) {
if(state_proposal$direction == -1 && is.matrix(state_proposal$valid_state$position)) {
# Sort backward doubled trajectory reversely
state_proposal$valid_state <- lapply(state_proposal$valid_state, function(x) apply(x, 2, rev))
state$leftmost <- state_proposal$leftmost
state$valid_state <- unite_valid_states(state_proposal, state)
} else{
state$valid_state <- unite_valid_states(state, state_proposal)
state$rightmost <- state_proposal$rightmost
}
}
state$run <- state_proposal$run * is_U_turn(state = state)
tree_depth <- tree_depth + 1
state$run
# 1 means forward, -1 means backward doubling
state$direction <- sample(c(-1L, 1L), 1L)
state_proposal <- build_tree(state, tree_depth)
if(state_proposal$run) {
if(state_proposal$direction == -1 && is.matrix(state_proposal$valid_state$position)) {
# Sort backward doubled trajectory reversely
state_proposal$valid_state <- lapply(state_proposal$valid_state, function(x) apply(x, 2, rev))
state$leftmost <- state_proposal$leftmost
state$valid_state <- unite_valid_states(state_proposal, state)
} else{
state$valid_state <- unite_valid_states(state, state_proposal)
state$rightmost <- state_proposal$rightmost
}
}
state$run <- state_proposal$run * is_U_turn(state = state)
tree_depth <- tree_depth + 1
tree_depth
state$run
state$run
state$run
# 1 means forward, -1 means backward doubling
state$direction <- sample(c(-1L, 1L), 1L)
state_proposal <- build_tree(state, tree_depth)
if(state_proposal$run) {
if(state_proposal$direction == -1 && is.matrix(state_proposal$valid_state$position)) {
# Sort backward doubled trajectory reversely
state_proposal$valid_state <- lapply(state_proposal$valid_state, function(x) apply(x, 2, rev))
state$leftmost <- state_proposal$leftmost
state$valid_state <- unite_valid_states(state_proposal, state)
} else{
state$valid_state <- unite_valid_states(state, state_proposal)
state$rightmost <- state_proposal$rightmost
}
}
state$run <- state_proposal$run * is_U_turn(state = state)
tree_depth <- tree_depth + 1
state$run
is_U_turn(state = state)
state_proposal$run
# 1 means forward, -1 means backward doubling
state$direction <- sample(c(-1L, 1L), 1L)
state_proposal <- build_tree(state, tree_depth)
if(state_proposal$run) {
if(state_proposal$direction == -1 && is.matrix(state_proposal$valid_state$position)) {
# Sort backward doubled trajectory reversely
state_proposal$valid_state <- lapply(state_proposal$valid_state, function(x) apply(x, 2, rev))
state$leftmost <- state_proposal$leftmost
state$valid_state <- unite_valid_states(state_proposal, state)
} else{
state$valid_state <- unite_valid_states(state, state_proposal)
state$rightmost <- state_proposal$rightmost
}
}
state$run <- state_proposal$run * is_U_turn(state = state)
tree_depth <- tree_depth + 1
cat("trajectory = ", state$valid_state,
"\n direction = ", state$direction, "\n")
state$run
# 1 means forward, -1 means backward doubling
state$direction <- sample(c(-1L, 1L), 1L)
state_proposal <- build_tree(state, tree_depth)
if(state_proposal$run) {
if(state_proposal$direction == -1 && is.matrix(state_proposal$valid_state$position)) {
# Sort backward doubled trajectory reversely
state_proposal$valid_state <- lapply(state_proposal$valid_state, function(x) apply(x, 2, rev))
state$leftmost <- state_proposal$leftmost
state$valid_state <- unite_valid_states(state_proposal, state)
} else{
state$valid_state <- unite_valid_states(state, state_proposal)
state$rightmost <- state_proposal$rightmost
}
}
state$run <- state_proposal$run * is_U_turn(state = state)
tree_depth <- tree_depth + 1
state$run
state$run
# 1 means forward, -1 means backward doubling
state$direction <- sample(c(-1L, 1L), 1L)
state_proposal <- build_tree(state, tree_depth)
if(state_proposal$run) {
if(state_proposal$direction == -1 && is.matrix(state_proposal$valid_state$position)) {
# Sort backward doubled trajectory reversely
state_proposal$valid_state <- lapply(state_proposal$valid_state, function(x) apply(x, 2, rev))
state$leftmost <- state_proposal$leftmost
state$valid_state <- unite_valid_states(state_proposal, state)
} else{
state$valid_state <- unite_valid_states(state, state_proposal)
state$rightmost <- state_proposal$rightmost
}
}
state$run <- state_proposal$run * is_U_turn(state = state)
tree_depth <- tree_depth + 1
state$run
# 1 means forward, -1 means backward doubling
state$direction <- sample(c(-1L, 1L), 1L)
state_proposal <- build_tree(state, tree_depth)
if(state_proposal$run) {
if(state_proposal$direction == -1 && is.matrix(state_proposal$valid_state$position)) {
# Sort backward doubled trajectory reversely
state_proposal$valid_state <- lapply(state_proposal$valid_state, function(x) apply(x, 2, rev))
state$leftmost <- state_proposal$leftmost
state$valid_state <- unite_valid_states(state_proposal, state)
} else{
state$valid_state <- unite_valid_states(state, state_proposal)
state$rightmost <- state_proposal$rightmost
}
}
state$run <- state_proposal$run * is_U_turn(state = state)
state$run
state$valid_state
(t(momentum_r) %*% position_distance)
momentum_l <- state$leftmost$momentum
momentum_r <- state$rightmost$momentum
position_distance <- state$rightmost$position - state$leftmost$position
as.numeric((t(momentum_l) %*% position_distance) * (t(momentum_r) %*% position_distance))
left <- as.numeric((t(momentum_l) %*% position_distance)) >= 0
right <- as.numeric((t(momentum_r) %*% position_distance)) >= 0
left*right
#' Build Trees doubles the postitions and momentums and such the trajectory length
#'
#' Repatedly called by NUTS until run == FALSE, that is when a U-Turn is performed.
#'
#' @param position_leftm leftmost tajectory position state
#' @param position_rightm rightmost tajectory position state
#' @param momentum_leftm leftmost tajectory momentum state
#' @param momentum_rightm rightmost tajectory momentum state
#' @param slice drawn slice sample to validate position-/momentum steps
#' @param direction determines whether trajectory should explore foreward or backwards
#' @param tree_depth balanced treedepth with momentum and position states in the tree nodes
#' @param stepsize parsed spesize \epsilon to Leapfrog step function
#'
#' @return
#'
build_tree <- function(state, tree_depth, deltamax = 1000L) {
if(tree_depth == 0L) {
build_leaf(state, deltamax) # Basecase - take one leapfrogstep into direction
} else {
# Recursion- build left/right subtrees
state1 <- build_tree(state, tree_depth-1L, deltamax)
state <- build_tree(state1, tree_depth-1L, deltamax)
# if any state is 0 Stopping criteria is triggered for trajectory iterations
state$run <- state1$run * state$run * is_U_turn(state)
state$valid_state <- unite_valid_states(state1, state)
state
}
}
# ______________________________________________________________________________
#' Build One Tree
#'
#' Builds one tree doing a leapfrogstep in one direction
#'
#' @inheritParams build_tree
build_leaf <- function(state, deltamax) {
proposal_state <- if(state$direction == -1) {
state$leftmost <- do.call(leapfrog, c(state$leftmost,
"stepsize" = (state$direction * state$stepsize)))
} else {
state$rightmost <-  do.call(leapfrog, c(state$rightmost,
"stepsize" = (state$direction * state$stepsize)))
}
proposal_density <- do.call(joint_probability, proposal_state)
if(state$slice <= proposal_density) state$valid_state <- proposal_state
state$run <- 0 + (proposal_density > (log(state$slice) - deltamax))
state
}
# ______________________________________________________________________________
#' Is a U Turn made?
#'
#' Investigates if trajectory makes a U-Turn (if >= 0)
#' @inheritParams build_tree
is_U_turn <- function(state, direction) {
momentum_l <- state$leftmost$momentum
momentum_r <- state$rightmost$momentum
position_distance <- state$rightmost$position - state$leftmost$position
left <- as.numeric((t(momentum_l) %*% position_distance)) >= 0
right <- as.numeric((t(momentum_r) %*% position_distance)) >= 0
left * right
}
# ______________________________________________________________________________
#' Unite states
#'
#' unites 2 valid state sets in second state set
unite_valid_states <- function(state1, state2) {
state2$valid_state$position <- unique(rbind(state1$valid_state$position, state2$valid_state$position))
state2$valid_state$momentum <- unique(rbind(state1$valid_state$momentum, state2$valid_state$momentum))
state2$valid_state
}
# Initialize state to call on Build Tree
state <- initialize_state(position, momentum, slice, stepsize)
tree_depth <- 0L
# 1 means forward, -1 means backward doubling
state$direction <- sample(c(-1L, 1L), 1L)
state_proposal <- build_tree(state, tree_depth)
if(state_proposal$run) {
if(state_proposal$direction == -1 && is.matrix(state_proposal$valid_state$position)) {
# Sort backward doubled trajectory reversely
state_proposal$valid_state <- lapply(state_proposal$valid_state, function(x) apply(x, 2, rev))
state$leftmost <- state_proposal$leftmost
state$valid_state <- unite_valid_states(state_proposal, state)
} else{
state$valid_state <- unite_valid_states(state, state_proposal)
state$rightmost <- state_proposal$rightmost
}
}
state$run <- state_proposal$run * is_U_turn(state = state)
state$run
tree_depth <- tree_depth + 1
state$valid_state
state_proposal$run
# 1 means forward, -1 means backward doubling
state$direction <- sample(c(-1L, 1L), 1L)
state_proposal <- build_tree(state, tree_depth)
state_proposal
debugonce(build_leaf)
state_proposal <- build_tree(state, tree_depth)
function(state, deltamax) {
proposal_state <- if(state$direction == -1) {
state$leftmost <- do.call(leapfrog, c(state$leftmost,
"stepsize" = (state$direction * state$stepsize)))
} else {
state$rightmost <-  do.call(leapfrog, c(state$rightmost,
"stepsize" = (state$direction * state$stepsize)))
}
proposal_density <- do.call(joint_probability, proposal_state)
if(state$slice <= proposal_density) state$valid_state <- proposal_state
state$run <- 0 + (proposal_density > (log(state$slice) - deltamax))
state
}
proposal_density
log(state$slice)
(proposal_density > (log(state$slice) - deltamax))
state$slice <= proposal_density
state$slice
proposal_density
if(state_proposal$run) {
if(state_proposal$direction == -1 && is.matrix(state_proposal$valid_state$position)) {
# Sort backward doubled trajectory reversely
state_proposal$valid_state <- lapply(state_proposal$valid_state, function(x) apply(x, 2, rev))
state$leftmost <- state_proposal$leftmost
state$valid_state <- unite_valid_states(state_proposal, state)
} else{
state$valid_state <- unite_valid_states(state, state_proposal)
state$rightmost <- state_proposal$rightmost
}
}
proposal_density
proposal_density
proposal_density
state
state_proposal
if(state_proposal$run) {
if(state_proposal$direction == -1 && is.matrix(state_proposal$valid_state$position)) {
# Sort backward doubled trajectory reversely
state_proposal$valid_state <- lapply(state_proposal$valid_state, function(x) apply(x, 2, rev))
state$leftmost <- state_proposal$leftmost
state$valid_state <- unite_valid_states(state_proposal, state)
} else{
state$valid_state <- unite_valid_states(state, state_proposal)
state$rightmost <- state_proposal$rightmost
}
}
state$run <- state_proposal$run * is_U_turn(state = state)
state$run
tree_depth <- tree_depth + 1
state$valid_state
# 1 means forward, -1 means backward doubling
state$direction <- sample(c(-1L, 1L), 1L)
state_proposal <- build_tree(state, tree_depth)
state_proposal
if(state_proposal$run) {
if(state_proposal$direction == -1 && is.matrix(state_proposal$valid_state$position)) {
# Sort backward doubled trajectory reversely
state_proposal$valid_state <- lapply(state_proposal$valid_state, function(x) apply(x, 2, rev))
state$leftmost <- state_proposal$leftmost
state$valid_state <- unite_valid_states(state_proposal, state)
} else{
state$valid_state <- unite_valid_states(state, state_proposal)
state$rightmost <- state_proposal$rightmost
}
}
state$run <- state_proposal$run * is_U_turn(state = state)
state$run
tree_depth <- tree_depth + 1
state$valid_state
# 1 means forward, -1 means backward doubling
state$direction <- sample(c(-1L, 1L), 1L)
state_proposal <- build_tree(state, tree_depth)
state_proposal
if(state_proposal$run) {
if(state_proposal$direction == -1 && is.matrix(state_proposal$valid_state$position)) {
# Sort backward doubled trajectory reversely
state_proposal$valid_state <- lapply(state_proposal$valid_state, function(x) apply(x, 2, rev))
state$leftmost <- state_proposal$leftmost
state$valid_state <- unite_valid_states(state_proposal, state)
} else{
state$valid_state <- unite_valid_states(state, state_proposal)
state$rightmost <- state_proposal$rightmost
}
}
state$run <- state_proposal$run * is_U_turn(state = state)
state$run
tree_depth <- tree_depth + 1
state$valid_state
# 1 means forward, -1 means backward doubling
state$direction <- sample(c(-1L, 1L), 1L)
state_proposal <- build_tree(state, tree_depth)
if(state_proposal$run) {
if(state_proposal$direction == -1 && is.matrix(state_proposal$valid_state$position)) {
# Sort backward doubled trajectory reversely
state_proposal$valid_state <- lapply(state_proposal$valid_state, function(x) apply(x, 2, rev))
state$leftmost <- state_proposal$leftmost
state$valid_state <- unite_valid_states(state_proposal, state)
} else{
state$valid_state <- unite_valid_states(state, state_proposal)
state$rightmost <- state_proposal$rightmost
}
}
state$run <- state_proposal$run * is_U_turn(state = state)
tree_depth <- tree_depth + 1
state$run
state$valid_state
# 1 means forward, -1 means backward doubling
state$direction <- sample(c(-1L, 1L), 1L)
state_proposal <- build_tree(state, tree_depth)
if(state_proposal$run) {
if(state_proposal$direction == -1 && is.matrix(state_proposal$valid_state$position)) {
# Sort backward doubled trajectory reversely
state_proposal$valid_state <- lapply(state_proposal$valid_state, function(x) apply(x, 2, rev))
state$leftmost <- state_proposal$leftmost
state$valid_state <- unite_valid_states(state_proposal, state)
} else{
state$valid_state <- unite_valid_states(state, state_proposal)
state$rightmost <- state_proposal$rightmost
}
}
state$run <- state_proposal$run * is_U_turn(state = state)
state$run
tree_depth
state$valid_state
# 1 means forward, -1 means backward doubling
state$direction <- sample(c(-1L, 1L), 1L)
state_proposal <- build_tree(state, tree_depth)
if(state_proposal$run) {
if(state_proposal$direction == -1 && is.matrix(state_proposal$valid_state$position)) {
# Sort backward doubled trajectory reversely
state_proposal$valid_state <- lapply(state_proposal$valid_state, function(x) apply(x, 2, rev))
state$leftmost <- state_proposal$leftmost
state$valid_state <- unite_valid_states(state_proposal, state)
} else{
state$valid_state <- unite_valid_states(state, state_proposal)
state$rightmost <- state_proposal$rightmost
}
}
state$run <- state_proposal$run * is_U_turn(state = state)
tree_depth <- tree_depth + 1
state$valid_state
slice <- runif(1L, max = joint_probability(position, momentum))
valid_states <- structure(vector("list", length = 2L), names= c("position", "momentum"))
# Initialize state to call on Build Tree
state <- initialize_state(position, momentum, slice, stepsize)
tree_depth <- 0L
# 1 means forward, -1 means backward doubling
state$direction <- sample(c(-1L, 1L), 1L)
state_proposal <- build_tree(state, tree_depth)
state_proposal
if(state_proposal$run) {
if(state_proposal$direction == -1 && is.matrix(state_proposal$valid_state$position)) {
# Sort backward doubled trajectory reversely
state_proposal$valid_state <- lapply(state_proposal$valid_state, function(x) apply(x, 2, rev))
state$leftmost <- state_proposal$leftmost
state$valid_state <- unite_valid_states(state_proposal, state)
} else{
state$valid_state <- unite_valid_states(state, state_proposal)
state$rightmost <- state_proposal$rightmost
}
}
state$run <- state_proposal$run * is_U_turn(state = state)
state$run
tree_depth <- tree_depth + 1
